------------------------------------------------------------------------
#my Hashtag first code

import React, { useEffect, useState, useCallback } from "react";
import { useSelector, useDispatch } from "react-redux";

import Postcard from "../components/postcard";
import PostForm from "../components/postForm";
import "./App.css";
import { USER_INFO_REFRESH_ACTION } from "../reducers/actions";

const Hashtag = () => {
  const [posts, setPosts] = useState([]);
  const { post, userInfo } = useSelector((state) => state);

  const dispatch = useDispatch();

  console.log("get Hashtah Post", post);

  const onScroll = useCallback(() => {
    if (
      window.scrollY >
        document.documentElement.scrollHeight -
          document.documentElement.clientHeight -
          500 &&
      posts.length - 1 <= post.length
    ) {
      console.log("getNewpost");
      const postIndex = post.findIndex((post) => {
        return posts[posts.length - 1].id === post.id;
      });
      let i = 0;
      while (++i <= 5 && post[postIndex + i]) {
        posts.push(post[postIndex + i]);
      }
      console.log("scroll push", posts);
      dispatch({
        type: USER_INFO_REFRESH_ACTION,
        payload: userInfo,
      });
    }
  }, [dispatch, post, posts, userInfo]);

  useEffect(() => {
    window.addEventListener("scroll", onScroll);
    return () => {
      window.removeEventListener("scroll", onScroll);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (!posts[0] && posts.length <= 3) {
      let i = -1;
      while (++i <= 5 && post[i]) {
        posts.push(post[i]);
        console.log("posts check", i, post[i]);
      }
      dispatch({
        type: USER_INFO_REFRESH_ACTION,
        payload: userInfo,
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div>
      {userInfo && userInfo.username && <PostForm />}
      {posts.map((data) => {
        return <Postcard key={data.created_at} post={{ data }} />;
      })}
    </div>
  );
};

export default Hashtag;

-----------------------------------------------------------------------------




import React, { useEffect } from "react";
import { useSelector, useDispatch, useState } from "react-redux";

import Postcard from "../components/postcard";
import PostForm from "../components/postForm";
import "./App.css";
import { USER_INFO_REFRESH_ACTION } from "../reducers/actions";

let getDataCheck = false;

let posts = [];

const Hashtag = () => {
  const [renderingCheck, setRenderingCheck] = useState(false);
  const { post, userInfo } = useSelector((state) => state);

  const dispatch = useDispatch();

  console.log("get Hashtah Post", post);
  if (!posts[0] && posts.length <= 3) {
    let i = -1;
    while (++i <= 3) {
      posts.push(post[i]);
    }
    console.log("posts check", posts, posts.length);
  }

  const onScroll = () => {
    if (
      window.scrollY >
        document.documentElement.scrollHeight -
          document.documentElement.clientHeight -
          500 &&
      !getDataCheck &&
      posts.length - 1 < post.length
    ) {
      getDataCheck = true;
      console.log("getNewpost");
      const postIndex = post.findIndex((post) => {
        return posts[posts.length - 1].id === post.id;
      });
      let i = 0;
      while (++i <= 3) {
        posts.push(post[postIndex + i]);
      }
      console.log("scroll push", posts);
      //   setRenderingCheck(renderingCheck ? false : true);
      //   dispatch({
      //     type: USER_INFO_REFRESH_ACTION,
      //     payload: userInfo,
      //   });
    }
  };

  useEffect(() => {
    window.addEventListener("scroll", onScroll);
    return () => {
      window.removeEventListener("scroll", onScroll);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (!posts[0] && posts.length <= 3) {
      let i = -1;
      while (++i <= 3) {
        posts.push(post[i]);
      }
      //   setRenderingCheck(renderingCheck ? false : true);
      console.log("posts check", posts, posts.length);
      //   dispatch({
      //     type: USER_INFO_REFRESH_ACTION,
      //     payload: userInfo,
      //   });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [posts.length]);

  return (
    <div>
      {userInfo && userInfo.username && <PostForm />}
      {posts.map((data) => {
        return <Postcard key={data.created_at} post={{ data }} />;
      })}
    </div>
  );
};

export default Hashtag;






// "dev": "BROWSER='google-chrome-stable' nodemon --experimental-modules",
    // "start": "BROWSER='google-chrome-stable' react-scripts start",
    // "build": "react-scripts build",


router.post("/uploadPostImage", (req, res, next) => {
  console.log("uploda image data 😱😱😱\n", req);
  try {
    if (req.isAuthenticated()) {
      try {
        upload(req, res, (err) => {
          // console.log("user check", req);
          if (err instanceof multer.MulterError) {
            return next(err);
          } else if (err) {
            return next(err);
          }

          const data = req.query;
          // console.log("uploadPostImage data", data);
          return db.Image.destroy({
            where: { postId: data.postId },
          }).then(async (destroyResult) => {
            // console.log(
            //   "Image destroy state",
            //   destroyResult,
            //   data.postId,
            //   (await req).files
            // );
            if (!(await req).files[0]) {
              return res.send("Upload Complete! 🐳");
            }
            (await req).files.forEach((file) => {
              console.log("file info", file.filename);
              // console.log("file.path", file);
              db.Image.create({
                postId: data.postId ? data.postId : null,
                filename: file.filename,
                userId: data.userId ? data.userId : null,
              });
            });
            return res.json((await req).files);
          });
        });
      } catch (error) {
        console.error("😡 ", error);
        next(error);
      }
    } else {
      res.send("Login Please! 😱");
    }
  } catch (error) {
    console.error("😡 ", error);
    next(error);
  }
});

import React, { useState, useCallback, useRef, useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { Input, Button, Form, message, Upload, Modal } from "antd";
import { PlusOutlined } from "@ant-design/icons";
import axios from "axios";

import { PUBLISH_POST_ACTION, UPDATE_POST_ACTION } from "../reducers/actions";

const moment = require("moment");
const { now } = moment;

const FormData = require("form-data");
const { TextArea } = Input;

const formData = new FormData();

const PostForm = ({ post }) => {
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [previewVisible, setPreviewVisible] = useState(false);
  const [previewImage, setPreviewImage] = useState("");
  const [fileList, setFileList] = useState([]);

  const { userInfo } = useSelector((state) => state);

  const inputTitle = useRef(null);
  const inputContent = useRef(null);

  const dispatch = useDispatch();

  // useEffect(() => {
  //   if (post && post.id) {
  //     toDataURL("./logo192.png", function (dataUrl) {
  //       // console.log("RESULT:", dataUrl);
  //       var file = dataURLtoFile(
  //         dataUrl,
  //         moment(now()).format("YYYYMMDDhmmss") + post.images[0].filename
  //       );
  //       console.log(file);
  //       setFileList([
  //         {
  //           uid: "-1",
  //           name:
  //             moment(now()).format("YYYYMMDDhmmss") + post.images[0].filename,
  //           status: "done",
  //           originFileObj: file,
  //           url: "./logo192.png",
  //         },
  //       ]);
  //     });
  //   }
  // }, [post]);

  function toDataURL(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onload = function () {
      var reader = new FileReader();
      reader.onloadend = function () {
        callback(reader.result);
      };
      reader.readAsDataURL(xhr.response);
    };
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.send();
  }

  function dataURLtoFile(dataurl, filename) {
    var arr = dataurl.split(","),
      mime = arr[0].match(/:(.*?);/)[1],
      bstr = atob(arr[1]),
      n = bstr.length,
      u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new File([u8arr], filename, { type: mime });
  }

  const getBase64 = useCallback((file) => {
    console.log("getBase64", file);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject(error);
    });
  }, []);

  const handleCancel = useCallback(() => setPreviewVisible(false), []);

  const handlePreview = useCallback(
    async (file) => {
      if (!file.url && !file.preview) {
        file.preview = await getBase64(file.originFileObj);
      }

      setPreviewImage(file.url || file.preview);
      setPreviewVisible(true);
    },
    [getBase64]
  );

  const handleChange = useCallback(({ fileList }) => {
    console.log("filelist", fileList);
    setFileList(fileList);
  }, []);

  const uploadButton = (
    <div>
      <PlusOutlined />
      <div className="ant-upload-text">Upload</div>
    </div>
  );

  const onChangeTitle = useCallback((e) => {
    setContent(e.target.value);
  }, []);
  const onChangeContent = useCallback((e) => {
    setTitle(e.target.value);
  }, []);

  const updatePost = useCallback(() => {
    axios({
      method: "post",
      url: "/post/update",
      params: {
        id: post.id,
        title,
        content,
        now: moment(now()).format("YYYYMMDDhmmss"),
      },
      withCredentials: true,
    })
      .then((res) => {
        fileList.forEach((file) => {
          formData.append("file", file.originFileObj);
        });
        console.log("fileList", fileList);
        axios({
          method: "post",
          url: "/post/uploadPostImage",
          data: formData,
          params: {
            postId: res.data.id,
            //update 값 이용해 기존의 이미지와 교체 여부 확인
            update: true,
            formData,
          },
          withCredentials: true,
        })
          .then((images) => {
            console.log("upload", images, res);
            if (res.status === 200) {
              message.success("Upload post success with image!. 🐳");
            } else {
              message.success("Upload post success!. 🐳");
            }
            dispatch({
              type: UPDATE_POST_ACTION,
              payload: {
                post: { ...res.data, images: images.data, comments: [] },
              },
            });
            inputTitle.current.state.value = null;
            inputContent.current.state.value = null;
          })
          .catch((error) => {
            console.error("😡 ", error);
          });
      })
      .catch((error) => {
        console.error("😡 ", error);
      });
  }, [content, dispatch, fileList, post, title]);

  const onSubmit = useCallback(async () => {
    if (!(userInfo && userInfo.username)) {
      message.warning("Login Please! 😱");
      return;
    }

    if (post && post.id !== undefined) {
      updatePost();
      return;
    }

    axios({
      method: "post",
      url: "/post/publish",
      params: {
        title,
        content,
        now: moment(now()).format("YYYYMMDDhmmss"),
      },
      withCredentials: true,
    })
      .then((res) => {
        fileList.forEach((file) => {
          formData.append("file", file.originFileObj);
        });
        console.log("res", fileList[0], res);
        axios({
          method: "post",
          url: "/post/uploadPostImage",
          data: formData,
          params: { postId: res.data.id },
          withCredentials: true,
        })
          .then((images) => {
            console.log("upload", images, res);
            if (res.status === 200) {
              message.success("Upload post success with image!. 🐳");
            } else {
              message.success("Upload post success!. 🐳");
            }
            dispatch({
              type: PUBLISH_POST_ACTION,
              payload: {
                post: { ...res.data, images: images.data, comments: [] },
              },
            });
          })
          .catch((error) => {
            message.warning("Upload failed");
            console.error("😡 ", error);
          });
      })
      .then(() => {
        inputTitle.current.state.value = null;
        inputContent.current.state.value = null;
        setFileList([]);
      })
      .catch((error) => {
        console.error("😡 ", error);
      });
  }, [content, dispatch, fileList, post, title, updatePost, userInfo]);

  return (
    <Form
      style={{
        margin: " 0 auto",
        width: 350,
      }}
    >
      <Input
        placeholder="title"
        ref={inputTitle}
        allowClear
        onChange={onChangeContent}
      />
      <br />
      <br />
      <TextArea
        placeholder="content"
        ref={inputContent}
        allowClear
        onChange={onChangeTitle}
      />
      <br />
      <br />
      <div className="clearfix">
        <Upload
          action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
          listType="picture-card"
          fileList={fileList}
          onPreview={handlePreview}
          onChange={handleChange}
        >
          {fileList.length >= 8 ? null : uploadButton}
        </Upload>
        <Modal visible={previewVisible} footer={null} onCancel={handleCancel}>
          <img alt="example" style={{ width: "100%" }} src={previewImage} />
        </Modal>
      </div>
      <Button
        type="default"
        value="large"
        htmlType="submit"
        onClick={onSubmit}
        style={{
          display: "flex",
          flex: 1,
          alignItems: "center",
          justifyContent: "center",
          margin: "0 auto",
          width: 350,
        }}
      >
        publish
      </Button>
    </Form>
  );
};

export default React.memo(PostForm);


import React, { useEffect } from "react";
import { useSelector, useDispatch } from "react-redux";
import styled from "styled-components";
import axios from "axios";

import { GET_POST_DATA } from "../reducers/actions";
import Postcard from "../components/postcard";
import PostForm from "../components/postForm";
import "./App.css";

const Div = styled.div``;

// let getDataState = false;

const Profile = () => {
  const { post, userInfo } = useSelector((state) => state);

  const dispatch = useDispatch();

  console.log("Post.js", post);

  // const onScroll = () => {
  //   console.log(
  //     window.scrollY,
  //     document.documentElement.clientHeight,
  //     document.documentElement.scrollHeight
  //   );
  //   if (
  //     window.scrollY >
  //       document.documentElement.scrollHeight -
  //         document.documentElement.clientHeight &&
  //     !getDataState
  //   ) {
  //     // dispatch({
  //     //   type: GET_POST_DATA,
  //     //   payload: { id: post[0] ? post[0].id : -1 },
  //     // });
  //   }
  // };

  // useEffect(() => {
  //   window.addEventListener("scroll", onScroll);
  //   return () => {
  //     window.removeEventListener("scroll", onScroll);
  //   };
  // }, []);

  useEffect(() => {
    // console.log("post", post[0] ? post[0].id : parseInt(-1));
    axios({
      method: "get",
      url: "http://localhost:8080/post",
      // params: { id: post[0] ? post[0].id : parseInt(-1) },
    })
      .then((postData) => {
        dispatch({
          type: GET_POST_DATA,
          payload: postData.data,
        });
      })
      .catch((error) => {
        console.error("😡 ", error);
      });
  }, [dispatch, post, post.length]);

  return (
    <Div>
      {userInfo && userInfo.username && <PostForm />}
      {post.map((data) => {
        //postCard 컴포넌트 내에서 Comment컴포넌트를 출력할 때
        //모든 값을 출력하기 위해 마지막에 하나의 더미테이터가 필요
        //하지만 현재 페이지에서 리렌더링이 두번 되는 문제 발생
        //왜 그런지 모르겠는데 데이터 추가된 상태가 유지되서
        //이중으로 더미데이터가 삽입되는 현상을 보임
        //따라서 if문으로 더미 데이터가 1개만 넣어지도록 제한
        // const post = data;
        // if (
        //   (post.comments[1] &&
        //     post.comments[data.comments.length - 1].id !==
        //       post.comments[data.comments.length - 2].id) ||
        //   post.comments.length === 1
        // ) {
        //   post.comments = [
        //     ...data.comments,
        //     { ...data.comments[data.comments.length - 1], group: null },
        //   ];
        // }
        // console.log("data", post.comments);
        return <Postcard key={data.created_at} post={{ data }} />;
      })}
    </Div>
  );
};

export default Profile;


------------------------------------------------------------
import React, {
  createElement,
  useState,
  useEffect,
  useRef,
  useCallback,
} from "react";
import { useSelector, useDispatch } from "react-redux";
import { useHistory } from "react-router-dom";
import { Comment, Tooltip, Avatar, message, Input, Form, Button } from "antd";
import moment from "moment";
import {
  DislikeOutlined,
  LikeOutlined,
  DislikeFilled,
  LikeFilled,
  UserOutlined,
} from "@ant-design/icons";
import axios from "axios";
import Lightbox from "react-image-lightbox";
import PropTypes from "prop-types";

import Commentform from "./commentform";
import {
  COMMENT_REMOVE_ACTION,
  COMMENT_UPDATE_ACTION,
  SET_HASHTAG_ACTION,
  POST_LIST_REMOVE_ACTION,
  GET_COMMENT_ACTION,
} from "../reducers/actions";

const { TextArea } = Input;

const Reply = ({ post, comment }) => {
  const [likeVal, setLikes] = useState(0);
  const [likeState, setLikeState] = useState(false);
  const [dislikeVal, setDislikes] = useState(0);
  const [dislikeState, setDislikeState] = useState(false);
  const [changeState, setChangeState] = useState(false);
  const [commentValue, setCommentValue] = useState("");
  const [replyCommentState, setReplyCommentState] = useState(false);
  const [isOpenUserImage, setIsOpenUserImage] = useState(false);
  const commentForm = useRef(null);
  const { userInfo } = useSelector((state) => state);

  const dispatch = useDispatch();
  const history = useHistory();

  let subCommentList = null;
  let subCommentStore = [];

  let likeCount = comment.likes.length + likeVal;
  let dislikeCount = comment.dislikes.length + dislikeVal;

  //이미 좋아요 했을 시 1 더하고 아닐 시 -1 더한다.
  let pluelikeOrUnlikeVal = 0;

  useEffect(() => {
    axios({
      method: "post",
      url: "/post/comment/likeState",
      params: { userId: userInfo.id, commentId: comment.id },
      withCredentials: true,
    })
      .then((res) => {
        if (res.data === true) {
          console.log(
            "res.data",
            res.data,
            res.data === "true",
            res.data === true
          );
          setLikeState(true);
        }
      })
      .catch((error) => {
        console.error("😡 ", error);
      });

    axios({
      method: "post",
      url: "/post/comment/dislikeState",
      params: { userId: userInfo.id, commentId: comment.id },
      withCredentials: true,
    })
      .then((res) => {
        if (res.data === true) {
          setDislikeState(true);
        }
      })
      .catch((error) => {
        console.error("😡 ", error);
      });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    setReplyCommentState(false);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [comment.comments.length]);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const likeCheck = (res) => {
    console.log("likeCheck", res);
    if (res.status !== 201) {
      message.warning(res.data);
      return false;
    }

    if (res.data === "unLike") pluelikeOrUnlikeVal = -1;
    else pluelikeOrUnlikeVal = 1;
    return true;
  };

  const searchHashtag = useCallback(
    (hashtag) => {
      console.log("hashtag: ", hashtag);
      dispatch({
        type: POST_LIST_REMOVE_ACTION,
      });
      dispatch({
        type: SET_HASHTAG_ACTION,
        payload: { hashtag: hashtag },
      });
      window.scrollTo(0, 0);
      history.push("/hashtag");
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );

  const like = useCallback(() => {
    axios({
      method: "post",
      url: "/post/comment/like",
      params: { commentId: comment.id, postId: post.id },
      withCredentials: true,
    })
      .then((res) => {
        if (likeCheck(res)) {
          setLikes(likeVal === 0 ? pluelikeOrUnlikeVal : 0);
          setLikeState(likeState ? false : true);
        }
      })
      .catch((error) => {
        console.error("😡 ", error);
      });
  }, [comment.id, likeCheck, likeState, likeVal, pluelikeOrUnlikeVal, post.id]);

  const dislike = useCallback(() => {
    axios({
      method: "post",
      url: "/post/comment/dislike",
      params: { commentId: comment.id },
      withCredentials: true,
    })
      .then((res) => {
        if (likeCheck(res)) {
          setDislikes(dislikeVal === 0 ? pluelikeOrUnlikeVal : 0);
          setDislikeState(dislikeState ? false : true);
        }
      })
      .catch((error) => {
        console.error("😡 ", error);
      });
  }, [comment.id, dislikeState, dislikeVal, likeCheck, pluelikeOrUnlikeVal]);

  const commentRemove = useCallback(() => {
    console.log("comment Set check", comment);
    console.log("commentRemoveCheck");
    axios({
      method: "post",
      url: "/post/comment/remove",
      params: {
        commentId: comment.id,
        postId: post.id,
        group: comment.group,
        sort: comment.sort,
        force: false,
      },
      withCredentials: true,
    })
      .then((res) => {
        console.log("commentRemove response", res, comment.id, comment.postId);
        if (res.status === 201) {
          message.success(res.data);
        } else {
          message.warning(res.data);
        }

        comment.comments.forEach((comment) => {
          axios({
            method: "post",
            url: "/post/comment/remove",
            params: {
              commentId: comment.id,
              postId: post.id,
              group: comment.group,
              sort: comment.sort,
              force: true,
            },
            withCredentials: true,
          })
            .then((res) => {
              console.log(
                "commentRemove response",
                res,
                comment.id,
                comment.postId
              );
              axios({
                method: "get",
                url: "/post/comment",
                params: { postId: post.id },
              }).then((comments) => {
                console.log("comments data check", comments);
                dispatch({
                  type: GET_COMMENT_ACTION,
                  payload: {
                    postId: post.id,
                    comments: comments.data,
                  },
                });
              });
            })
            .catch((error) => {
              console.error("😡 ", error);
            });
        });
      })
      .then((res) => {
        console.log("res check", res);

        dispatch({
          type: COMMENT_REMOVE_ACTION,
          payload: {
            commentId: comment.id,
            postId: comment.postId,
          },
        });
      })
      .catch((error) => {
        console.error("😡 ", error);
      });
  }, [comment, dispatch, post.id]);

  const commentValueChange = useCallback(
    (e) => {
      setCommentValue(e.target.value);
      console.log("commentValue", commentValue);
    },
    [commentValue]
  );

  const commentChangeSubmit = useCallback(() => {
    setChangeState(false);

    if (commentValue.trim() === "") {
      return message.warning("Please include the contents.! 😱");
    }
    axios({
      method: "post",
      url: "/post/comment/change",
      withCredentials: true,
      params: {
        commentId: comment.id,
        comment: commentValue.trimRight(),
        postId: post.id,
      },
    })
      .then((res) => {
        console.log("commnetUpdateResponse", res);

        if (res.status !== 201) {
          return message.warning(res.data);
        }
        message.success(res.data);

        dispatch({
          type: COMMENT_UPDATE_ACTION,
          payload: {
            commentId: comment.id,
            postId: comment.postId,
            comment: commentValue.trimRight(),
          },
        });
      })
      .catch((error) => {
        console.error("😡 ", error);
      });
  }, [comment.id, comment.postId, commentValue, dispatch, post.id]);

  const actions = useCallback(
    [
      <span key="comment-basic-like">
        <Tooltip title="Like">
          {console.log("likeState", likeState)}
          {createElement(likeState === true ? LikeFilled : LikeOutlined, {
            onClick: like,
          })}
        </Tooltip>
        <span className="comment-action">{likeCount}</span>
      </span>,
      <span key=' key="comment-basic-dislike"'>
        <Tooltip title="Dislike">
          {React.createElement(
            dislikeState === true ? DislikeFilled : DislikeOutlined,
            {
              onClick: dislike,
            }
          )}
        </Tooltip>
        <span className="comment-action">{dislikeCount}</span>
      </span>,
      <span
        key="comment-basic-reply-to"
        onClick={() => setReplyCommentState(replyCommentState ? false : true)}
      >
        {userInfo && userInfo.id ? "Reply to" : ""}
      </span>,
      <span
        key="comment-basic-change"
        onClick={() => setChangeState(changeState ? false : true)}
      >
        {userInfo && userInfo.id === comment.user.id ? "Change" : ""}
      </span>,
      <span key="comment-basic-remove" onClick={commentRemove}>
        {userInfo && userInfo.id === comment.user.id ? "Remove" : ""}
      </span>,
    ],
    []
  );

  return (
    <Comment
      style={{ width: "300px", margin: "0 auto" }}
      actions={actions}
      author={comment.user ? comment.user.nickname : "not found"}
      avatar={
        comment.user.images[0] &&
        comment.user.images[0].filename !== undefined ? (
          <>
            <Avatar
              src={`../../public/images/${comment.user.images[0].filename}`}
              alt="Han Solo"
              onClick={() => setIsOpenUserImage(true)}
            />
            {isOpenUserImage && (
              <Lightbox
                //css변경할 때 사용
                reactModalStyle={{
                  overlay: {},
                  content: {},
                }}
                mainSrc={`./images/${comment.user.images[0].filename}`}
                onCloseRequest={() => setIsOpenUserImage(false)}
              />
            )}
          </>
        ) : (
          <>
            <Avatar icon={<UserOutlined />} />
          </>
        )
      }
      content={
        changeState ? (
          <Form>
            <TextArea
              rows={4}
              style={{
                margin: "0 0 0.5rem 0",
                width: "300px",
                display: "block",
              }}
              onChange={commentValueChange}
              ref={commentForm}
              defaultValue={comment.comment}
            />
            <Button type="primary" onClick={commentChangeSubmit}>
              submit
            </Button>
          </Form>
        ) : (
          comment.comment.split(" ").map((comment) => {
            // console.log("comment check", comment);
            if (comment.charAt(0) === "#") {
              return (
                <span
                  style={{ color: "#3399ff", cursor: "pointer" }}
                  onClick={() => {
                    searchHashtag(comment.slice(1));
                  }}
                >
                  {comment}&nbsp;
                </span>
              );
            } else {
              return <span>{comment}&nbsp;</span>;
            }
          })
        )
      }
      datetime={
        <Tooltip title={moment().format("YYYY-MM-DD HH:mm:ss")}>
          <span>{moment(comment.created_at).fromNow()}</span>
        </Tooltip>
      }
    >
      {replyCommentState && <Commentform post={post} comment={comment} />}
      {(comment.comments[0] &&
        comment.comments.forEach((childComment) => {
          // console.log(
          //   "comment sub commnet",
          //   childComment.comment,
          // );
          const commentsSize = comment.comments.length;
          const subCommentsSize =
            subCommentList && subCommentList.comments[0]
              ? subCommentList.comments.length
              : 0;
          if (
            subCommentList !== null &&
            childComment.depth <= comment.depth + 1
          ) {
            if (subCommentsSize > 0) {
              //이전값을 기준으로 출력할 값을 정하기 때문에
              //순회가 끝나도 하나의  값이 처리되지 못해 끝에 더미값을 푸쉬한다.
              subCommentList.comments.push({
                ...subCommentList.comments[commentsSize - 1],
                depth: subCommentList.comments[0].depth,
              });
              subCommentStore.push(subCommentList);
              subCommentList = null;
              // console.log("subCommentStore", subCommentStore);
            } else {
              subCommentStore.push(subCommentList);
            }
            //데이더 변질을 막기 위해 스프레드 연산자 사용
            subCommentList = { ...childComment };
            subCommentList.comments = [];
          } else if (subCommentList === null) {
            subCommentList = { ...childComment };
            subCommentList.comments = [];
            // return <Reply comment={subCommentList} />;
          } else {
            subCommentList.comments.push(childComment);
          }
        })) ||
        //댓글이 최신순으로 정렬되어있어 오랜된 댓글부터 보기위해 뒤집어준다.
        subCommentStore.reverse().map((comment) => {
          // console.log("subCommentCheck", comment);
          return <Reply post={post} comment={comment} />;
        })}
    </Comment>
  );
};

Reply.propTypes = {
  post: PropTypes.object,
  comment: PropTypes.object,
};

export default Reply;
